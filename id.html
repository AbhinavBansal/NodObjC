<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head><title>Id | NodObjC v0.0.8</title><link href="assets/styles.css" rel="stylesheet"/><script src="assets/jquery-1.7.1.js" type="text/javascript"></script><script src="assets/script.js" type="text/javascript"></script></head><body><div id="content"><a href="http://github.com/TooTallNate/NodObjC" id="title"><h1>NodObjC</h1><h3>The NodeJS &#8646; Objective-C Bridge</h3></a><h2>Id</h2><div class="part"><div class="desc"><p>The 'id' function is essentially the "base class" for all Objective-C<br />objects that get passed around JS-land.</p></div></div><div class="part"><h3>wrap()</h3><div class="desc"><p>Wraps up a pointer that is expected to be a compatible Objective-C<br />object that can recieve messages. This function returns a cached version of the<br />wrapped function after the first time it is invoked on a given Pointer, using<br />Objective-C's internal association map for objects.</p></div><button class="show-code">Show Code</button><pre class="code"><code>function wrap (pointer) {
  debug('id#wrap(%d)', pointer.address)
  var rtn = null
    , p = core.objc_getAssociatedObject(pointer, KEY)
  if (p.isNull()) {
    rtn = createFunctionWrapper(pointer)
    // Store the wrapped instance internally
    var ref = new core.Pointer(core.TYPE_SIZE_MAP.Object)
    // don't call free() automatically when ref gets GC'd
    // TODO: we're gonna have to free this pointer someday!
    // XXX: use node-weak to get a callback when the wrapper is GC'd
    ref.free = false
    ref.putObject(rtn)
    core.objc_setAssociatedObject(pointer, KEY, ref, 0)
  } else {
    debug('returning cached associated instance')
    rtn = p.getObject()
  }
  //assert.equal(rtn.pointer.address, pointer.address)
  return rtn
}</code></pre></div><div class="part"><h3>proto.msgSend()</h3><div class="desc"><p>A very important function that <em>does the message sending</em> between<br />Objective-C objects. When you do <code>array('addObject', anObject)</code>, this<br /><code>msgSend</code> function is the one that finally gets called to do the dirty work.</p>

<p>This function accepts a String selector as the first argument, and an Array<br />of (wrapped) values that get passed to the the message. This function takes<br />care of unwrapping the passing in arguments an wrapping up the result value,<br />if necessary.</p>

<p>If you wanted to monkey-patch <em>every</em> message that got sent out from an<br />object though NodObjC, this is the place to do it.</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.msgSend = function msgSend (sel, args) {
  debug('sending message:', sel, args)
  var types = this._getTypes(sel, args)
    , argTypes = types[1]
    , msgSendFunc = core.get_objc_msgSend(types)
    , unwrappedArgs = core.unwrapValues([this, sel].concat(args), argTypes)
    , rtn
  try {
    rtn = msgSendFunc.apply(null, unwrappedArgs)
  } catch (e) {
    throw exception.wrap(e)
  }
  // Process the return value into a wrapped value if needed
  return core.wrapValue(rtn, types[0])
}</code></pre></div><div class="part"><h3>proto._getTypes()</h3><div class="desc"><p>Accepts a SEL and queries the current object for the return type and<br />argument types for the given selector. If current object does not implment<br />that selector, then check the superclass, and repeat recursively until<br />a subclass that responds to the selector is found, or until the base class<br />is found.</p>

<p>TODO: Just merge this logic with <code>msgSend()</code>? It's not used anywhere else</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto._getTypes = function getTypes (sel, args) {
  var c = this.getClass()
    , t = c._getTypesClass(sel, this.isClass)
  if (!t) {
    // Unknown selector being send to object. This *may* still be valid, we
    // assume all args are type 'id' and return is 'id'.
    debug('unknown selector being sent:', sel)
    t = [ '@', [ '@', ':', ].concat(args.map(function () { return '@' })) ]
  }
  return t
}</code></pre></div><div class="part"><h3>proto.getClass()</h3><div class="desc"><p>Retrieves the wrapped Class instance for this object.</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.getClass = function getClass () {
  return Class.wrap(this._getClassPointer())
}</code></pre></div><div class="part"><h3>proto._getClassPointer()</h3><div class="desc"><p>Returns the node-ffi pointer for the class of this object.</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto._getClassPointer = function getClassPointer () {
  return core.object_getClass(this.pointer)
}</code></pre></div><div class="part"><h3>proto.getClassName()</h3><div class="desc"><p>Calls 'object_getClassName()' on this object.</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.getClassName = function getClassName () {
  return core.object_getClassName(this.pointer)
}</code></pre></div><div class="part"><h3>proto.setClass()</h3><div class="desc"><p>Dynamically changes the object's Class.</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.setClass = function setClass (newClass) {
  return Class.wrap(core.object_setClass(this.pointer, newClass.pointer))
}</code></pre></div><div class="part"><h3>proto.ancestors()</h3><div class="desc"><p>Walks up the inheritance chain and returns an Array of Strings of<br />superclasses.</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.ancestors = function ancestors () {
  var rtn = []
    , c = this.getClass()
  while (c) {
    rtn.push(c.getName())
    c = c.getSuperclass()
  }
  return rtn
}</code></pre></div><div class="part"><h3>proto.ivar()</h3><div class="desc"><p>Getter/setter function for instance variables (ivars) of the object,<br />If just a name is passed in, then this function gets the ivar current value.<br />If a name and a new value are passed in, then this function sets the ivar.</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.ivar = function ivar (name, value) {
  // TODO: Add support for passing in a wrapped Ivar instance as the `name`
  if (arguments.length &gt; 1) {
    // setter
    debug('setting ivar:', name, value)
    var ivar = this.isClass
             ? this.getClassVariable(name)
             : this.getClass().getInstanceVariable(name)
      , unwrapped = core.unwrapValue(value, ivar.getTypeEncoding())
    return core.object_setIvar(this.pointer, ivar.pointer, unwrapped)
  } else {
    // getter
    debug('getting ivar:', name)
    var ptr = new core.Pointer(core.TYPE_SIZE_MAP.pointer)
      , ivar = core.object_getInstanceVariable(this.pointer, name, ptr)
    return core.wrapValue(ptr.getPointer(), core.ivar_getTypeEncoding(ivar))
  }
}</code></pre></div><div class="part"><h3>proto.ivars()</h3><div class="desc"><p>Returns an Array of Strings of the names of the ivars that the current object<br />contains. This function can iterate through the object's superclasses<br />recursively, if you specify a 'maxDepth' argument.</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.ivars = function ivars (maxDepth, sort) {
  var rtn = []
    , c = this.getClass()
    , md = maxDepth || 1
    , depth = 0
  while (c &amp;&amp; depth++ &lt; md) {
    var is = c.getInstanceVariables()
      , i = is.length
    while (i--) {
      if (!~rtn.indexOf(is[i])) rtn.push(is[i])
    }
    c = c.getSuperclass()
  }
  return sort === false ? rtn : rtn.sort()
}</code></pre></div><div class="part"><h3>proto.methods()</h3><div class="desc"><p>Returns an Array of Strings of the names of methods that the current object<br />will respond to. This function can iterate through the object's superclasses<br />recursively, if you specify a 'maxDepth' number argument.</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.methods = function methods (maxDepth, sort) {
  var rtn = []
    , c = this.getClass()
    , md = maxDepth || 1
    , depth = 0
  while (c &amp;&amp; depth++ &lt; md) {
    var ms = c.getInstanceMethods()
      , i = ms.length
    while (i--) {
      if (!~rtn.indexOf(ms[i])) rtn.push(ms[i])
    }
    c = c.getSuperclass()
  }
  return sort === false ? rtn : rtn.sort()
}</code></pre></div><div class="part"><h3>proto.ref()</h3><div class="desc"><p>Returns a <strong>node-ffi</strong> pointer pointing to this object. This is a convenience<br />function for methods that take pointers to objects (i.e. <code>NSError**</code>).</p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.ref = function ref () {
  debug('id#ref()')
  var ptr = this.pointer.ref()
  return ptr
}</code></pre></div><div class="part"><h3>proto.toString()</h3><div class="desc"><p>The id wrap's overidden toString() function proxies up to the id's<br />description method: <code>[[id description] UTF8String]</code></p></div><button class="show-code">Show Code</button><pre class="code"><code>proto.toString = function toString () {
  return this('description')('UTF8String')
}

proto.inspect = function inspect () {
  return this.toString()
}</code></pre></div></div><div id="footer">NodObjC &copy; 2011-2012 Nathan Rajlich. Documentation generated by 
<a href="https://github.com/visionmedia/dox">dox</a>.
</div><a href="http://github.com/TooTallNate/NodObjC"><img id="ribbon" src="https://a248.e.akamai.net/assets.github.com/img/4c7dc970b89fd04b81c8e221ba88ff99a06c6b61/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f77686974655f6666666666662e706e67" alt="Fork me on GitHub"/></a></body></html>