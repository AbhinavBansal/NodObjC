<!DOCTYPE html><html><head><title>Core | NodObjC v0.0.12</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="assets/styles.css" rel="stylesheet"><link href="assets/ir_black.css" rel="stylesheet"><script src="assets/jquery-1.7.1.js" type="text/javascript"></script><script src="assets/script.js" type="text/javascript"></script></head><body><div id="content"><a href="index.html" id="title"><h1>NodObjC</h1><h3>The NodeJS &#8646; Objective-C Bridge</h3></a><div class="toc"><span class="page"><a href="block.html">block</a></span><span class="page"><a href="bridgesupport.html">bridgesupport</a></span><span class="page"><a href="class.html">class</a></span><span class="page"><a href="core.html">core</a></span><span class="page"><a href="exception.html">exception</a></span><span class="page"><a href="ffi-extend.html">ffi-extend</a></span><span class="page"><a href="global.html">global</a></span><span class="page"><a href="id.html">id</a></span><span class="page"><a href="imp.html">imp</a></span><span class="page"><a href="import.html">import</a></span><span class="page"><a href="index.html">index</a></span><span class="page"><a href="ivar.html">ivar</a></span><span class="page"><a href="method.html">method</a></span><span class="page"><a href="sel.html">sel</a></span><span class="page"><a href="struct.html">struct</a></span><span class="page"><a href="types.html">types</a></span></div><h2>Core</h2><div class="part"><div class="desc"><p>This &#39;core&#39; module is the <code>libffi</code> wrapper. All required native
functionality is instantiated and then exported in this module.

</p>
<h3>References:</h3>
<ul>
<li><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html">Objective-C Runtime Reference</a></li>
</ul>
</div></div><div class="part"><h3>exports.getClassList()</h3><div class="desc"><p>Convienience function to return an Array of Strings of the names of every
class currently in the runtime. This gets used at the during the import
process get a name of the new classes that have been loaded.
TODO: Could be replaced with a native binding someday for speed. Not overly
      important as this function is only called during import()</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.getClassList = <span class="function"><span class="keyword">function</span> <span class="title">getClassList</span> <span class="params">()</span> {</span>
  <span class="comment">// First get just the count</span>
  <span class="keyword">var</span> num = objc.objc_getClassList(<span class="literal">null</span>, <span class="number">0</span>)
    , rtn = []
  <span class="keyword">if</span> (num > <span class="number">0</span>) {
    <span class="keyword">var</span> s = ffi.Bindings.TYPE_SIZE_MAP.pointer
      , c = <span class="literal">null</span>
      , classes = <span class="keyword">new</span> ffi.Pointer(s * num)
      , cursor = classes
    objc.objc_getClassList(classes, num)
    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;num; i++) {
      c = cursor.getPointer()
      rtn.push(objc.class_getName(c))
      cursor = cursor.seek(s)
    }
    <span class="comment">// free() not needed since ffi allocated the buffer, and will free() with V8's GC</span>
  }
  <span class="keyword">return</span> rtn
}</code></pre></div><div class="part"><h3>exports.copyProtocolList()</h3><div class="desc"><p>Gets a list of the currently loaded Protocols in the runtime.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.copyProtocolList = <span class="function"><span class="keyword">function</span> <span class="title">copyProtocolList</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> num = <span class="keyword">new</span> ffi.Pointer(exports.TYPE_SIZE_MAP.uint32)
    , rtn = []
    , protos = objc.objc_copyProtocolList(num)
    , p = protos
    , count = num.getUInt32()
  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++) {
    <span class="keyword">var</span> cur = p.getPointer()
      , name = objc.protocol_getName(cur)
    rtn.push(name)
    p = p.seek(exports.TYPE_SIZE_MAP.pointer)
  }
  ffi.free(protos)
  <span class="keyword">return</span> rtn
}</code></pre></div><div class="part"><h3>exports.copyIvarList()</h3><div class="desc"><p>Copies and returns an Array of the instance variables defined by a given
Class pointer. To get class variables, call this function on a metaclass.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.copyIvarList = <span class="function"><span class="keyword">function</span> <span class="title">copyIvarList</span> <span class="params">(classPtr)</span> {</span>
  <span class="keyword">var</span> numIvars = <span class="keyword">new</span> ffi.Pointer(exports.TYPE_SIZE_MAP.uint32)
    , rtn = []
    , ivars = exports.class_copyIvarList(classPtr, numIvars)
    , p = ivars
    , count = numIvars.getUInt32()
  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++) {
    <span class="keyword">var</span> cur = p.getPointer()
      , name = exports.ivar_getName(cur)
    rtn.push(name)
    p = p.seek(exports.TYPE_SIZE_MAP.pointer)
  }
  ffi.free(ivars)
  <span class="keyword">return</span> rtn
}</code></pre></div><div class="part"><h3>exports.copyMethodList()</h3><div class="desc"><p>Copies and returns an Array of the instance methods the given Class pointer
implements. To get class methods, call this function with a metaclass.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.copyMethodList = <span class="function"><span class="keyword">function</span> <span class="title">copyMethodList</span> <span class="params">(classPtr)</span> {</span>
  <span class="keyword">var</span> numMethods = <span class="keyword">new</span> ffi.Pointer(exports.TYPE_SIZE_MAP.uint32)
    , rtn = []
    , methods = exports.class_copyMethodList(classPtr, numMethods)
    , p = methods
    , count = numMethods.getUInt32()
  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++) {
    <span class="keyword">var</span> cur = p.getPointer()
      , name = SEL.toString(exports.method_getName(cur))
    rtn.push(name)
    p = p.seek(exports.TYPE_SIZE_MAP.pointer)
  }
  ffi.free(methods)
  <span class="keyword">return</span> rtn
}</code></pre></div><div class="part"><h3>exports.copyMethodDescriptionList()</h3><div class="desc"><p>Iterates over the Methods defined by a Protocol.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.copyMethodDescriptionList = <span class="function"><span class="keyword">function</span> <span class="title">copyMethodDescriptionList</span> <span class="params">(protocolPtr, required, instance)</span> {</span>
  <span class="keyword">var</span> numMethods = <span class="keyword">new</span> ffi.Pointer(exports.TYPE_SIZE_MAP.uint32)
    , methods = exports.protocol_copyMethodDescriptionList(protocolPtr, required, instance, numMethods)
    , rtn = []
    , p = methods
    , count = numMethods.getUInt32()
  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++) {
    <span class="keyword">var</span> cur = <span class="keyword">new</span> exports.objc_method_description(p)
    rtn.push(SEL.toString(cur.name))
    p = p.seek(ffi.sizeOf(exports.objc_method_description))
  }
  ffi.free(methods)
  <span class="keyword">return</span> rtn
}</code></pre></div><div class="part"><h3>exports.getMethodReturnType()</h3><div class="desc"><p>Convienience function to get the String return type of a Method pointer.
Takes care of free()ing the returned pointer, as is required.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.getMethodReturnType = <span class="function"><span class="keyword">function</span> <span class="title">getMethodReturnType</span> <span class="params">(method)</span> {</span>
  <span class="keyword">return</span> getStringAndFree(objc.method_copyReturnType(method))
}

exports.getMethodArgTypes = <span class="function"><span class="keyword">function</span> <span class="title">getMethodArgTypes</span> <span class="params">(method)</span> {</span>
  <span class="keyword">var</span> num = objc.method_getNumberOfArguments(method)
    , rtn = []
  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">2</span>; i&lt;num; i++) {
    rtn.push(getStringAndFree(objc.method_copyArgumentType(method, i)))
  }
  <span class="keyword">return</span> rtn
}

exports.getStringAndFree = <span class="function"><span class="keyword">function</span> <span class="title">getStringAndFree</span> <span class="params">(ptr)</span> {</span>
  <span class="keyword">var</span> str = ptr.getCString()
  ffi.free(ptr)
  <span class="keyword">return</span> str
}</code></pre></div><div class="part"><h3>exports.get_objc_msgSend()</h3><div class="desc"><p>Creates and/or returns an appropriately wrapped up &#39;objc_msgSend&#39; function
based on the given Method description info.
TODO: Move this into a node-ffi helper class thingy.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.get_objc_msgSend = <span class="function"><span class="keyword">function</span> <span class="title">get_objc_msgSend</span> <span class="params">(objcTypes)</span> {</span>
  <span class="keyword">var</span> type = []
    , rtn = [ types.map(objcTypes[<span class="number">0</span>]), type ]
    , args = objcTypes[<span class="number">1</span>]
    , i = <span class="number">0</span>
    , l = args.length
  <span class="keyword">for</span> (; i&lt;l; i++) {
    type.push(types.map(args[i]))
  }
  <span class="comment">// Stringify the types</span>
  <span class="keyword">var</span> key = rtn.toString()
  <span class="comment">//console.warn('INFO: types key: %s', key)</span>

  <span class="comment">// first check the cache</span>
  <span class="keyword">if</span> (msgSendCache[key]) <span class="keyword">return</span> msgSendCache[key]
  debug(<span class="string">'key not found in msgSendCache, generating new copy:'</span>, key)

  <span class="comment">// If we got here, then create a new objc_msgSend ffi wrapper</span>
  <span class="comment">// TODO: Don't use the Library helper, use ffi low-level API</span>
  <span class="keyword">var</span> lib = <span class="keyword">new</span> ffi.Library(<span class="literal">null</span>, {
    objc_msgSend: rtn
  })
  <span class="comment">// return and cache at the same time</span>
  <span class="keyword">return</span> msgSendCache[key] = lib.objc_msgSend
}</code></pre></div><div class="part"><h3>exports.get_objc_msgSendSuper()</h3><div class="desc"><p>Creates and/or returns an appropriately wrapped up &#39;objc_msgSendSuper&#39;
function based on the given Method description info.
TODO: Move this into a node-ffi helper class thingy.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.get_objc_msgSendSuper = <span class="function"><span class="keyword">function</span> <span class="title">get_objc_msgSendSuper</span> <span class="params">(objcTypes)</span> {</span>
  <span class="keyword">var</span> type = []
    , rtn = [ types.map(objcTypes[<span class="number">0</span>]), type ]
    , args = objcTypes[<span class="number">1</span>]
    , i = <span class="number">0</span>
    , l = args.length
  <span class="keyword">for</span> (; i&lt;l; i++) {
    type.push(types.map(args[i]))
  }
  <span class="comment">// Stringify the types</span>
  <span class="keyword">var</span> key = rtn.toString()
  <span class="comment">//console.warn('INFO: types key: %s', key)</span>

  <span class="comment">// first check the cache</span>
  <span class="keyword">if</span> (msgSendCacheSuper[key]) <span class="keyword">return</span> msgSendCacheSuper[key]
  debug(<span class="string">'key not found in msgSendCacheSuper, generating new copy:'</span>, key)

  <span class="comment">// If we got here, then create a new objc_msgSend ffi wrapper</span>
  <span class="comment">// TODO: Don't use the Library helper, use ffi low-level API</span>
  <span class="keyword">var</span> lib = <span class="keyword">new</span> ffi.Library(<span class="literal">null</span>, {
    objc_msgSendSuper: rtn
  })
  <span class="comment">// return and cache at the same time</span>
  <span class="keyword">return</span> msgSendCache[key] = lib.objc_msgSendSuper
}


<span class="comment">// Struct type returned by `protocol_getMethodDescription`.</span>
exports.objc_method_description = ffi.Struct([
    [<span class="string">'pointer'</span>, <span class="string">'name'</span>]
  , [<span class="string">'string'</span>, <span class="string">'types'</span>]
])</code></pre></div><div class="part"><h3>exports.wrapValue()</h3><div class="desc"><p>Wraps up a node-ffi pointer if needed (not needed for Numbers, etc.)</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.wrapValue = <span class="function"><span class="keyword">function</span> <span class="title">wrapValue</span> <span class="params">(val, type)</span> {</span>
  debug(<span class="string">'wrapValue():'</span>, type)
  <span class="keyword">if</span> (val === <span class="literal">null</span> || (val.isNull &amp;&amp; val.isNull())) <span class="keyword">return</span> <span class="literal">null</span>
  <span class="keyword">var</span> rtn = val
  <span class="keyword">if</span> (type.function_pointer) {
    <span class="keyword">if</span> (type.type == <span class="string">'@?'</span>) {
      <span class="keyword">return</span> block.createBlock(val, type)
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> IMP.createUnwrapperFunction(val, type)
    }
  }
  <span class="comment">// get the raw type from Type objects</span>
  <span class="keyword">if</span> (type.type) type = type.type
  <span class="keyword">if</span> (type == <span class="string">'@'</span>) {
    rtn = id.wrap(val)
  } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">'#'</span>) {
    rtn = Class.wrap(val)
  } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">':'</span>) {
    rtn = SEL.toString(val)
  } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">'B'</span>) {
    rtn = val ? <span class="literal">true</span> : <span class="literal">false</span>
  }
  <span class="keyword">if</span> (rtn)
    rtn._type = type
  <span class="keyword">return</span> rtn
}</code></pre></div><div class="part"><h3>exports.wrapValues()</h3><div class="desc"><p>Accepts an Array of raw objc pointers and other values, and an array of ObjC
types, and returns an array of wrapped values where appropriate.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.wrapValues = <span class="function"><span class="keyword">function</span> <span class="title">wrapValues</span> <span class="params">(values, types)</span> {</span>
  <span class="keyword">var</span> len = values.length
    , rtn = []
  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++) {
    rtn.push(exports.wrapValue(values[i], types[i]))
  }
  <span class="keyword">return</span> rtn
}</code></pre></div><div class="part"><h3>exports.unwrapValue()</h3><div class="desc"><p>Unwraps a previously wrapped NodObjC object.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.unwrapValue = <span class="function"><span class="keyword">function</span> <span class="title">unwrapValue</span> <span class="params">(val, type)</span> {</span>
  debug(<span class="string">'unwrapValue():'</span>, type)
  <span class="keyword">var</span> rtn = val
  <span class="keyword">if</span> (type.function_pointer) {
    <span class="keyword">if</span> (type.type == <span class="string">'@?'</span>) {
      <span class="keyword">return</span> block.getPointer(val, type)
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> IMP.createWrapperPointer(val, type)
    }
  }
  <span class="comment">// get the raw type from Type objects</span>
  <span class="keyword">if</span> (type.type) type = type.type
  <span class="keyword">if</span> (type == <span class="string">'@'</span> || type == <span class="string">'#'</span>) {
    <span class="keyword">if</span> (!val) <span class="keyword">return</span> <span class="literal">null</span>
    rtn = val.pointer
  } <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">':'</span>) {
    rtn = SEL.toSEL(val)
  }
  <span class="keyword">if</span> (rtn)
    rtn._type = type
  <span class="keyword">return</span> rtn
}</code></pre></div><div class="part"><h3>exports.unwrapValues()</h3><div class="desc"><p>Accepts an Array of wrapped NodObjC objects and other values, and an array
of their cooresponding ObjC types, and returns an array of unwrapped values.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>exports.unwrapValues = <span class="function"><span class="keyword">function</span> <span class="title">unwrapValues</span> <span class="params">(values, types)</span> {</span>
  debug(<span class="string">'unwrapValues():'</span>, types)
  <span class="keyword">var</span> len = values.length
    , rtn = []
  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++) {
    rtn.push(exports.unwrapValue(values[i], types[i]))
  }
  <span class="keyword">return</span> rtn
}

<span class="keyword">var</span> types = require(<span class="string">'./types'</span>)
  , SEL = require(<span class="string">'./sel'</span>)
  , id = require(<span class="string">'./id'</span>)
  , Class = require(<span class="string">'./class'</span>)
  , IMP = require(<span class="string">'./imp'</span>)
  , block = require(<span class="string">'./block'</span>)</code></pre></div></div><div id="footer">NodObjC &copy; 2011-2012 Nathan Rajlich. Documentation generated by <a href="https://github.com/visionmedia/dox">dox</a>.</div><a href="http://github.com/TooTallNate/NodObjC"><img id="ribbon" src="https://a248.e.akamai.net/camo.github.com/e6bef7a091f5f3138b8cd40bc3e114258dd68ddf/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub"></a></body></html>
