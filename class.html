<!DOCTYPE html><html><head><title>Class | NodObjC v0.0.12</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="assets/styles.css" rel="stylesheet"><link href="assets/ir_black.css" rel="stylesheet"><script src="assets/jquery-1.7.1.js" type="text/javascript"></script><script src="assets/script.js" type="text/javascript"></script></head><body><div id="content"><a href="index.html" id="title"><h1>NodObjC</h1><h3>The NodeJS &#8646; Objective-C Bridge</h3></a><div class="toc"><span class="page"><a href="block.html">block</a></span><span class="page"><a href="bridgesupport.html">bridgesupport</a></span><span class="page"><a href="class.html">class</a></span><span class="page"><a href="core.html">core</a></span><span class="page"><a href="exception.html">exception</a></span><span class="page"><a href="ffi-extend.html">ffi-extend</a></span><span class="page"><a href="global.html">global</a></span><span class="page"><a href="id.html">id</a></span><span class="page"><a href="imp.html">imp</a></span><span class="page"><a href="import.html">import</a></span><span class="page"><a href="index.html">index</a></span><span class="page"><a href="ivar.html">ivar</a></span><span class="page"><a href="method.html">method</a></span><span class="page"><a href="sel.html">sel</a></span><span class="page"><a href="struct.html">struct</a></span><span class="page"><a href="types.html">types</a></span></div><h2>Class</h2><div class="part"><div class="desc"><p>The <code>Class</code> class is a subclass of <code>id</code>. Instances of <code>Class</code> wrap an
Objective C <em>&quot;Class&quot;</em> instance.

</p>
<p>You can retrieve <code>Class</code> instances by getting a reference to a global class
(i.e. <code>$.NSObject</code>), or by other methods/functions that return <code>Class</code>
instances normally (i.e. <code>$.NSClassFromString($(&#39;NSObject&#39;))</code>).</p>
</div></div><div class="part"><h3>getClass()</h3><div class="desc"><div class="private"><div class="caution"></div>This is a private function used internally by <code>NodObjC</code>. You should <b>not</b> need to use this function in
your code.</div><p>Gets a wrapped Class instance based off the given name.
Also takes care of returning a cached version when available.
</p>
</div><button class="show-code">Show Code</button><pre class="code"><code><span class="function"><span class="keyword">function</span> <span class="title">getClass</span> <span class="params">(className)</span> {</span>
  debug(<span class="string">'getClass:'</span>, className)
  <span class="keyword">var</span> rtn = classCache[className]
  <span class="keyword">if</span> (rtn) {
    debug(<span class="string">'the classCache actually worked!!!!'</span>, className)
  } <span class="keyword">else</span> {
    <span class="keyword">var</span> pointer = core.objc_getClass(className)
    rtn = exports.wrap(pointer, className)
  }
  <span class="keyword">return</span> rtn
}</code></pre></div><div class="part"><h3>wrap()</h3><div class="desc"><div class="private"><div class="caution"></div>This is a private function used internally by <code>NodObjC</code>. You should <b>not</b> need to use this function in
your code.</div><p>Wraps the given <em>pointer</em>, which should be an Objective-C Class, and returns
a <code>Class</code> instance.
</p>
</div><button class="show-code">Show Code</button><pre class="code"><code><span class="function"><span class="keyword">function</span> <span class="title">wrap</span> <span class="params">(pointer, className)</span> {</span>
  debug(<span class="string">'Class#wrap(%d, %s)'</span>, pointer.address, className)
  <span class="keyword">var</span> w = id.wrap(pointer)
  w.__proto__ = proto
  pointer._type = <span class="string">'#'</span>
  <span class="comment">// optionally cache when a class name is given</span>
  <span class="keyword">if</span> (className) {
    classCache[className] = w
  }
  <span class="keyword">return</span> w
}

<span class="comment">// Flag used by id#msgSend()</span>
proto.isClass = <span class="literal">true</span></code></pre></div><div class="part"><h3>Class#extend()</h3><div class="desc"><p>Creates a subclass of this class with the given name and optionally a
number of extra bytes that will be allocated with each instance. The
returned <code>Class</code> instance should have <code>addMethod()</code> and <code>addIvar()</code> called on
it as needed before use, and then <code>register()</code> when you&#39;re ready to use it.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.extend = <span class="function"><span class="keyword">function</span> <span class="title">extend</span> <span class="params">(className, extraBytes)</span> {</span>
  <span class="keyword">var</span> c = core.objc_allocateClassPair(<span class="keyword">this</span>.pointer, className, extraBytes || <span class="number">0</span>)
  <span class="keyword">if</span> (c.isNull()) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'New Class could not be allocated: '</span> + className)
  }
  <span class="keyword">return</span> exports.wrap(c, className)
}</code></pre></div><div class="part"><h3>Class#register()</h3><div class="desc"><p>Calls objc_registerClassPair() on the class pointer.
This must be called on the class <em>after</em> all &#39;addMethod()&#39; and &#39;addIvar()&#39;
calls are made, and <em>before</em> the newly created class is used for real.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.register = <span class="function"><span class="keyword">function</span> <span class="title">register</span> <span class="params">()</span> {</span>
  core.objc_registerClassPair(<span class="keyword">this</span>.pointer)
  _global[<span class="keyword">this</span>.getName()] = <span class="keyword">this</span>
  <span class="keyword">return</span> <span class="keyword">this</span>
}</code></pre></div><div class="part"><h3>Class#addMethod()</h3><div class="desc"><p>Adds a new Method to the Class. Instances of the class (even already existing
ones) will have the ability to invoke the method. This may be called at any
time on any class.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.addMethod = <span class="function"><span class="keyword">function</span> <span class="title">addMethod</span> <span class="params">(selector, type, func)</span> {</span>
  <span class="keyword">var</span> parsed = types.parse(type)
    , selRef = SEL.toSEL(selector)
    , funcPtr = IMP.createWrapperPointer(func, parsed)
  <span class="comment">// flatten the type</span>
  <span class="keyword">var</span> typeStr = parsed[<span class="number">0</span>] + parsed[<span class="number">1</span>].join(<span class="string">''</span>)
  <span class="keyword">if</span> (!core.class_addMethod(<span class="keyword">this</span>.pointer, selRef, funcPtr, typeStr)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'method "'</span> + selector + <span class="string">'" was NOT sucessfully added to Class: '</span> + <span class="keyword">this</span>.getName())
  }
  <span class="keyword">return</span> <span class="keyword">this</span>
}</code></pre></div><div class="part"><h3>Class#addIvar()</h3><div class="desc"><p>Adds an Ivar to the Class. Instances of the class will contain the specified
instance variable. This MUST be called after .extend() but BEFORE .register()</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.addIvar = <span class="function"><span class="keyword">function</span> <span class="title">addIvar</span> <span class="params">(name, type, size, alignment)</span> {</span>
  <span class="keyword">if</span> (!size) {
    <span class="comment">// Lookup the size of the type when needed</span>
    <span class="keyword">var</span> ffiType = types.map(type)
    size = core.TYPE_SIZE_MAP[ffiType]
  }
  <span class="keyword">if</span> (!alignment) {
    <span class="comment">// Also set the alignment when needed. This formula is from Apple's docs:</span>
    <span class="comment">//   For variables of any pointer type, pass log2(sizeof(pointer_type)).</span>
    alignment = Math.log(size) / Math.log(<span class="number">2</span>)
  }
  <span class="keyword">if</span> (!core.class_addIvar(<span class="keyword">this</span>.pointer, name, size, alignment, type)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'ivar "'</span> + name + <span class="string">'" was NOT sucessfully added to Class: '</span> + <span class="keyword">this</span>.getName())
  }
  <span class="keyword">return</span> <span class="keyword">this</span>
}</code></pre></div><div class="part"><h3>Class#addProtocol()</h3><div class="desc"><p>Adds a <code>Protocol</code> to the list of protocols that this class &quot;conforms to&quot;
(a.k.a &quot;implements&quot;). Usually, an implementation object is passed in that
defines the Protocol&#39;s defined methods onto the class.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.addProtocol = <span class="function"><span class="keyword">function</span> <span class="title">addProtocol</span> <span class="params">(protocolName, impl)</span> {</span>
  <span class="keyword">var</span> informal = require(<span class="string">'./bridgesupport'</span>).informal_protocols[protocolName]
    , formal = core.objc_getProtocol(protocolName)

  console.error(core.copyMethodDescriptionList(formal, <span class="number">1</span>, <span class="number">1</span>))
  console.error(core.copyMethodDescriptionList(formal, <span class="number">0</span>, <span class="number">0</span>))
  console.error(core.copyMethodDescriptionList(formal, <span class="number">1</span>, <span class="number">0</span>))
  console.error(core.copyMethodDescriptionList(formal, <span class="number">0</span>, <span class="number">1</span>))
}

proto._getSuperclassPointer = <span class="function"><span class="keyword">function</span> <span class="title">getSuperclassPointer</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> core.class_getSuperclass(<span class="keyword">this</span>.pointer)
}

proto.getName = <span class="function"><span class="keyword">function</span> <span class="title">getName</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> core.class_getName(<span class="keyword">this</span>.pointer)
}

proto.isMetaClass = <span class="function"><span class="keyword">function</span> <span class="title">isMetaClass</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> !!core.class_isMetaClass(<span class="keyword">this</span>.pointer)
}

proto.getInstanceSize = <span class="function"><span class="keyword">function</span> <span class="title">getInstanceSize</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> core.class_getInstanceSize(<span class="keyword">this</span>.pointer)
}

proto.getIvarLayout = <span class="function"><span class="keyword">function</span> <span class="title">getIvarLayout</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> core.class_getIvarLayout(<span class="keyword">this</span>.pointer)
}</code></pre></div><div class="part"><h3>Class#getSuperclass()</h3><div class="desc"><p>Get&#39;s a Class instance&#39;s superclass. If the current class is a base class,
then this will return null.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.getSuperclass = <span class="function"><span class="keyword">function</span> <span class="title">getSuperclass</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> superclassPointer = <span class="keyword">this</span>._getSuperclassPointer()
  <span class="keyword">if</span> (superclassPointer.isNull()) <span class="keyword">return</span> <span class="literal">null</span>
  <span class="keyword">return</span> exports.wrap(superclassPointer)
}

proto.setSuperclass = <span class="function"><span class="keyword">function</span> <span class="title">setSuperclass</span> <span class="params">(superclass)</span> {</span>
  <span class="keyword">return</span> exports.wrap(<span class="keyword">this</span>._setSuperclassPointer(superclass.pointer))
}

proto._setSuperclassPointer = <span class="function"><span class="keyword">function</span> <span class="title">setSuperclassPointer</span> <span class="params">(superclassPointer)</span> {</span>
  <span class="keyword">return</span> core.class_setSuperclass(<span class="keyword">this</span>.pointer, superclassPointer)
}

proto.getInstanceVariable = <span class="function"><span class="keyword">function</span> <span class="title">getInstanceVariable</span> <span class="params">(name)</span> {</span>
  <span class="keyword">return</span> ivar.wrap(<span class="keyword">this</span>._getInstanceVariable(name))
}

proto._getInstanceVariable = <span class="function"><span class="keyword">function</span> <span class="title">_getInstanceVariable</span> <span class="params">(name)</span> {</span>
  <span class="keyword">return</span> core.class_getInstanceVariable(<span class="keyword">this</span>.pointer, name)
}

proto.getClassVariable = <span class="function"><span class="keyword">function</span> <span class="title">getClassVariable</span> <span class="params">(name)</span> {</span>
  <span class="keyword">return</span> ivar.wrap(<span class="keyword">this</span>._getClassVariable(name))
}

proto._getClassVariable = <span class="function"><span class="keyword">function</span> <span class="title">_getClassVariable</span> <span class="params">(name)</span> {</span>
  <span class="keyword">return</span> core.class_getClassVariable(<span class="keyword">this</span>.pointer, name)
}

proto.getInstanceMethod = <span class="function"><span class="keyword">function</span> <span class="title">getInstanceMethod</span> <span class="params">(sel)</span> {</span>
  <span class="keyword">return</span> method.wrap(<span class="keyword">this</span>._getInstanceMethod(SEL.toSEL(sel)))
}

proto._getInstanceMethod = <span class="function"><span class="keyword">function</span> <span class="title">_getInstanceMethod</span> <span class="params">(selPtr)</span> {</span>
  <span class="keyword">return</span> core.class_getInstanceMethod(<span class="keyword">this</span>.pointer, selPtr)
}

proto.getClassMethod = <span class="function"><span class="keyword">function</span> <span class="title">getClassMethod</span> <span class="params">(sel)</span> {</span>
  <span class="keyword">return</span> method.wrap(<span class="keyword">this</span>._getClassMethod(SEL.toSEL(sel)))
}

proto._getClassMethod = <span class="function"><span class="keyword">function</span> <span class="title">_getClassMethod</span> <span class="params">(selPtr)</span> {</span>
  <span class="keyword">return</span> core.class_getClassMethod(<span class="keyword">this</span>.pointer, selPtr)
}

proto._getTypesClass = <span class="function"><span class="keyword">function</span> <span class="title">getTypesClass</span> <span class="params">(sel, isClass)</span> {</span>
  <span class="comment">//console.error('_getTypesClass: %s, isClass: %d', sel, isClass)</span>
  <span class="keyword">var</span> method = <span class="keyword">this</span>[<span class="string">'get'</span>+(isClass ? <span class="string">'Class'</span> : <span class="string">'Instance'</span>)+<span class="string">'Method'</span>](sel)
  <span class="keyword">return</span> method ? method.getTypes() : <span class="literal">null</span>
}

proto.getVersion = <span class="function"><span class="keyword">function</span> <span class="title">getVersion</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> core.class_getVersion(<span class="keyword">this</span>.pointer)
}

proto.setVersion = <span class="function"><span class="keyword">function</span> <span class="title">setVersion</span> <span class="params">(v)</span> {</span>
  <span class="keyword">return</span> core.class_setVersion(<span class="keyword">this</span>.pointer, v)
}</code></pre></div><div class="part"><h3>Class#getClassVariables()</h3><div class="desc"><p>Returns an Array of the class variables this Class has. Superclass variables
are not included.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.getClassVariables = <span class="function"><span class="keyword">function</span> <span class="title">getClassVariables</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> core.copyIvarList(<span class="keyword">this</span>._getClassPointer())
}</code></pre></div><div class="part"><h3>Class#getInstanceVariables()</h3><div class="desc"><p>Returns an Array of the instance variables this Class has. Superclass
variables are not included.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.getInstanceVariables = <span class="function"><span class="keyword">function</span> <span class="title">getInstanceVariables</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> core.copyIvarList(<span class="keyword">this</span>.pointer)
}</code></pre></div><div class="part"><h3>Class#getClassMethods()</h3><div class="desc"><p>Returns an Array of all the class methods this Class responds to.
This function returns the raw, unsorted result of copyMethodList().</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.getClassMethods = <span class="function"><span class="keyword">function</span> <span class="title">getClassMethods</span> <span class="params">()</span> {</span>
  <span class="comment">// getClassPointer() on a Class actually gets a pointer to the metaclass</span>
  <span class="keyword">return</span> core.copyMethodList(<span class="keyword">this</span>._getClassPointer())
}</code></pre></div><div class="part"><h3>Class#getInstanceMethods()</h3><div class="desc"><p>Returns an Array of all the instance methods an instance of this Class will
respond to.
This function returns the raw, unsorted result of copyMethodList().</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.getInstanceMethods = <span class="function"><span class="keyword">function</span> <span class="title">getInstanceMethods</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> core.copyMethodList(<span class="keyword">this</span>.pointer)
}</code></pre></div><div class="part"><h3>Class#createPointer()</h3><div class="desc"><p>Allocates a new pointer to this type. The pointer points to <code>nil</code> initially.
This is meant for creating a pointer to hold an NSError*, and pass a ref()
to it into a method that accepts an &#39;error&#39; double pointer.
XXX: Tentative API - name will probably change</p>
</div><button class="show-code">Show Code</button><pre class="code"><code>proto.createPointer = <span class="function"><span class="keyword">function</span> <span class="title">createPointer</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> ptr = core.Pointer.alloc(<span class="string">'pointer'</span>, core.Pointer.NULL)
  ptr._type = <span class="string">'@'</span>
  <span class="keyword">return</span> ptr
}</code></pre></div></div><div id="footer">NodObjC &copy; 2011-2012 Nathan Rajlich. Documentation generated by <a href="https://github.com/visionmedia/dox">dox</a>.</div><a href="http://github.com/TooTallNate/NodObjC"><img id="ribbon" src="https://a248.e.akamai.net/camo.github.com/e6bef7a091f5f3138b8cd40bc3e114258dd68ddf/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub"></a></body></html>
