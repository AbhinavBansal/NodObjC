<!DOCTYPE html><html><head><title>Bridgesupport | NodObjC v0.0.9</title><link href="assets/styles.css" rel="stylesheet"><link href="assets/ir_black.css" rel="stylesheet"><script src="assets/jquery-1.7.1.js" type="text/javascript"></script><script src="assets/script.js" type="text/javascript"></script></head><body><div id="content"><a href="index.html" id="title"><h1>NodObjC</h1><h3>The NodeJS &#8646; Objective-C Bridge</h3></a><h2>Bridgesupport</h2><div class="part"><div class="desc"><p>This module takes care of loading the BridgeSupport XML files for a given framework, and parsing the data into the given framework object.</p>

<h2>Reference</h2>

<p><a href='http://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man5/BridgeSupport.5.html'>http://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man5/BridgeSupport.5.html</a></p></div></div><div class="part"><div class="desc"><p>Architecture-specific functions that return the Obj-C type or value from one of these BridgeSupport XML nodes.</p></div><button class="show-code">Show Code</button><pre class="code"><code><span class="keyword">var</span> getType
  , getValue
<span class="keyword">if</span> (process.arch == <span class="string">'x64'</span>) {
  <span class="comment">// 64-bit specific functions</span>
  debug(<span class="string">'using 64-bit &quot;type&quot; and &quot;value&quot; attributes'</span>)
  getType = <span class="function"><span class="keyword">function</span> <span class="params">(a)</span> {</span>
    <span class="keyword">return</span> a.type64 || a.type
  }
  getValue = <span class="function"><span class="keyword">function</span> <span class="params">(a)</span> {</span>
    <span class="keyword">return</span> a.value64 || a.value
  }
} <span class="keyword">else</span> {
  <span class="comment">// 32-bit / ARM specific functions</span>
  debug(<span class="string">'using regular &quot;type&quot; and &quot;value&quot; attributes'</span>)
  getType = <span class="function"><span class="keyword">function</span> <span class="params">(a)</span> {</span>
    <span class="keyword">return</span> a.type
  }
  getValue = <span class="function"><span class="keyword">function</span> <span class="params">(a)</span> {</span>
    <span class="keyword">return</span> a.value
  }
}</code></pre></div><div class="part"><h3>bridgesupport()</h3><div class="desc"><p>Attempts to retrieve the BridgeSupport files for the given framework. It synchronously reads the contents of the bridgesupport files and parses them in order to add the symbols that the Obj-C runtime functions cannot determine.</p></div><button class="show-code">Show Code</button><pre class="code"><code><span class="function"><span class="keyword">function</span> <span class="title">bridgesupport</span> <span class="params">(fw)</span> {</span>

  <span class="keyword">var</span> bridgeSupportDir = join(fw.basePath, <span class="string">'Resources'</span>, <span class="string">'BridgeSupport'</span>)
    , bridgeSupportXML = join(bridgeSupportDir, fw.name + BS_SUFFIX)
    , bridgeSupportDylib = join(bridgeSupportDir, fw.name + DY_SUFFIX)

  <span class="comment">// If there's no BridgeSupport file, then bail...</span>
  <span class="keyword">if</span> (!exists(bridgeSupportXML)) {
    debug(<span class="string">'no BridgeSupport files found for framework &quot;%s&quot; at:'</span>, fw.name, bridgeSupportXML)
    <span class="keyword">return</span>
  }

  <span class="comment">// Load the &quot;inline&quot; dylib if it exists</span>
  <span class="keyword">if</span> (exists(bridgeSupportDylib)) {
    debug(<span class="string">'importing &quot;inline&quot; dylib for framework &quot;%s&quot; at:'</span>, fw.name, bridgeSupportDylib)
    fw.inline = core.dlopen(bridgeSupportDylib)
  }

  <span class="keyword">var</span> contents = fs.readFileSync(bridgeSupportXML, <span class="string">'utf8'</span>)
    , parser = sax.parser(<span class="literal">true</span>)
    , gotEnd = <span class="literal">false</span>
    , curObj = <span class="literal">null</span>

  parser.onerror = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> {</span> <span class="keyword">throw</span> e }
  parser.onopentag = <span class="function"><span class="keyword">function</span> <span class="params">(node)</span> {</span>
    <span class="keyword">var</span> a = node.attributes
    <span class="comment">//a._name = node.name</span>
    <span class="keyword">switch</span> (node.name) {
      <span class="keyword">case</span> <span class="string">'depends_on'</span>:
        Import(a.path, <span class="literal">true</span>)
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'class'</span>:
        curObj = exports.classes[a.name] || a
        exports.classes[curObj.name] = curObj
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'method'</span>:
        <span class="comment">// Normalize the 'type' for the platform</span>
        a.type = getType(a)
        a._parent = curObj
        <span class="keyword">if</span> (!curObj.methods)
          curObj.methods = []
        curObj.methods.push(a)
        curObj = a
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'arg'</span>:
        <span class="comment">// Normalize the 'type' for the platform</span>
        a.type = getType(a)
        a._parent = curObj
        <span class="keyword">if</span> (!curObj.args)
          curObj.args = []
        curObj.args.push(a)
        curObj = a
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'retval'</span>:
        <span class="comment">// Normalize the 'type' for the platform</span>
        a.type = getType(a)
        a._parent = curObj
        curObj.retval = a
        curObj = a
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'signatures'</span>:
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'string_constant'</span>:
        _global[a.name] = getValue(a)
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'enum'</span>:
        _global[a.name] = Number(getValue(a))
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'struct'</span>:
        <span class="comment">// TODO: Remove the try/catch when all the Struct formats are supported</span>
        <span class="comment">//       Still need Array and Union support.</span>
        <span class="keyword">try</span> {
          _global[a.name] = struct.getStruct(getType(a))
        } <span class="keyword">catch</span> (e) {
          <span class="comment">//console.error('FAILED:\n', a)</span>
          <span class="comment">//console.error(e.stack)</span>
        }
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'field'</span>:
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'cftype'</span>:
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'constant'</span>:
        defineConstant(a, fw)
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'function'</span>:
        curObj = a
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'opaque'</span>:
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'informal_protocol'</span>:
        curObj = exports.informal_protocols[a.name] || a
        exports.informal_protocols[curObj.name] = curObj
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'function_alias'</span>:
        <span class="keyword">break</span>;
      <span class="keyword">default</span>:
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'unkown tag: '</span>+ node.name)
        <span class="keyword">break</span>;
    }
  }
  parser.onclosetag = <span class="function"><span class="keyword">function</span> <span class="params">(node)</span> {</span>
    <span class="keyword">switch</span> (node) {
      <span class="keyword">case</span> <span class="string">'function'</span>:
        <span class="comment">// Binded functions will be lazy-loaded. We simply define a getter that</span>
        <span class="comment">// does the creation magic the first time, and replaces the getter with</span>
        <span class="comment">// the binded function</span>
        defineFunction(curObj, fw)
        curObj = <span class="literal">null</span>
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'arg'</span>:
      <span class="keyword">case</span> <span class="string">'method'</span>:
      <span class="keyword">case</span> <span class="string">'retval'</span>:
        <span class="keyword">var</span> c = curObj._parent
        curObj._parent = <span class="literal">null</span>
        curObj = c
        <span class="keyword">break</span>;
    }
  }
  parser.onend = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    gotEnd = <span class="literal">true</span>
  }

  <span class="comment">// Parse the contents of the file. This should happen synchronously.</span>
  parser.write(contents).close()

  assert.ok(gotEnd, <span class="string">'could not parse BridgeSupport files synchronously'</span>)
}</code></pre></div><div class="part"><h3>defineConstant()</h3><div class="desc"><p>Sets up a <constant> tag onto the global exports. These start out as simple JS getters, so that the underlying symbol pointer can be lazy-loaded on-demand.</p></div><button class="show-code">Show Code</button><pre class="code"><code><span class="function"><span class="keyword">function</span> <span class="title">defineConstant</span> <span class="params">(a, fw)</span> {</span>
  <span class="keyword">var</span> name = a.name
    , type = getType(a)
  _global.__defineGetter__(name, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> ptr = fw.lib.get(name) <span class="comment">// TODO: Cache the pointer after the 1st call</span>
    ptr._type = <span class="string">'^'</span> + type
    <span class="keyword">var</span> val = ptr.deref()
    <span class="keyword">return</span> val
  })
}</code></pre></div><div class="part"><h3>defineFunction()</h3><div class="desc"><p>Sets up a <function> tag onto the global exports. These start out as simple JS getters, so that the underlying function pointer can be lazy-loaded on-demand.</p></div><button class="show-code">Show Code</button><pre class="code"><code><span class="function"><span class="keyword">function</span> <span class="title">defineFunction</span> <span class="params">(a, fw)</span> {</span>
  <span class="keyword">var</span> name = a.name
    , isInline = a.inline == <span class="string">'true'</span>
  _global.__defineGetter__(name, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//console.error(require('util').inspect(a, true, 10))</span>
    <span class="comment">// TODO: Handle 'variadic' arg functions (NSLog), will require</span>
    <span class="comment">//       a &quot;function generator&quot; to get a Function from the passed</span>
    <span class="comment">//       in args (and guess at the types that were passed in...)</span>
    debug(<span class="string">'loading function pointer for:'</span>, name)
    <span class="keyword">if</span> (isInline) {
      assert.ok(fw.inline, name+<span class="string">', '</span>+fw.name+<span class="string">': declared inline but could not find inline dylib!'</span>)
    }
    <span class="keyword">var</span> ptr = (isInline ? fw.inline : fw.lib).get(name)
      , unwrapper = IMP.createUnwrapperFunction(ptr, a)
    unwrapper.info = a
    <span class="keyword">delete</span> _global[name]
    <span class="keyword">return</span> _global[name] = unwrapper
  })
}</code></pre></div></div><div id="footer">NodObjC &copy; 2011-2012 Nathan Rajlich. Documentation generated by 
<a href="https://github.com/visionmedia/dox">dox</a>.
</div><a href="http://github.com/TooTallNate/NodObjC"><img id="ribbon" src="https://a248.e.akamai.net/assets.github.com/img/4c7dc970b89fd04b81c8e221ba88ff99a06c6b61/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f77686974655f6666666666662e706e67" alt="Fork me on GitHub"></a></body></html>
