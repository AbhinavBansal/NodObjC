<!DOCTYPE html><html><head><title>Bridgesupport | NodObjC v0.0.12</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link href="assets/styles.css" rel="stylesheet"><link href="assets/ir_black.css" rel="stylesheet"><script src="assets/jquery-1.7.1.js" type="text/javascript"></script><script src="assets/script.js" type="text/javascript"></script></head><body><div id="content"><a href="index.html" id="title"><h1>NodObjC</h1><h3>The NodeJS &#8646; Objective-C Bridge</h3></a><div class="toc"><span class="page"><a href="block.html">block</a></span><span class="page"><a href="bridgesupport.html">bridgesupport</a></span><span class="page"><a href="class.html">class</a></span><span class="page"><a href="core.html">core</a></span><span class="page"><a href="exception.html">exception</a></span><span class="page"><a href="ffi-extend.html">ffi-extend</a></span><span class="page"><a href="global.html">global</a></span><span class="page"><a href="id.html">id</a></span><span class="page"><a href="imp.html">imp</a></span><span class="page"><a href="import.html">import</a></span><span class="page"><a href="index.html">index</a></span><span class="page"><a href="ivar.html">ivar</a></span><span class="page"><a href="method.html">method</a></span><span class="page"><a href="sel.html">sel</a></span><span class="page"><a href="struct.html">struct</a></span><span class="page"><a href="types.html">types</a></span></div><h2>Bridgesupport</h2><div class="part"><div class="desc"><p>This module takes care of loading the BridgeSupport XML files for a given
framework, and parsing the data into the given framework object.

</p>
<h3>References:</h3>
<ul>
<li><a href="http://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man5/BridgeSupport.5.html"><code>man 5 BridgeSupport</code></a></li>
<li><a href="http://bridgesupport.macosforge.org">BridgeSupport MacOS Forge website</a></li>
</ul>
</div></div><div class="part"><h3>bridgesupport()</h3><div class="desc"><p>Attempts to retrieve the BridgeSupport files for the given framework.
It synchronously reads the contents of the bridgesupport files and parses
them in order to add the symbols that the Obj-C runtime functions cannot
determine.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code><span class="function"><span class="keyword">function</span> <span class="title">bridgesupport</span> <span class="params">(fw)</span> {</span>

  <span class="keyword">var</span> bridgeSupportDir = join(fw.basePath, <span class="string">'Resources'</span>, <span class="string">'BridgeSupport'</span>)
    , bridgeSupportXML = join(bridgeSupportDir, fw.name + BS_SUFFIX)
    , bridgeSupportDylib = join(bridgeSupportDir, fw.name + DY_SUFFIX)

  <span class="comment">// If there's no BridgeSupport file, then bail...</span>
  <span class="keyword">if</span> (!exists(bridgeSupportXML)) {
    debug(<span class="string">'no BridgeSupport files found for framework "%s" at:'</span>, fw.name, bridgeSupportXML)
    <span class="keyword">return</span>
  }

  <span class="comment">// Load the "inline" dylib if it exists</span>
  <span class="keyword">if</span> (exists(bridgeSupportDylib)) {
    debug(<span class="string">'importing "inline" dylib for framework "%s" at:'</span>, fw.name, bridgeSupportDylib)
    fw.inline = core.dlopen(bridgeSupportDylib)
  }

  <span class="keyword">var</span> contents = read(bridgeSupportXML, <span class="string">'utf8'</span>)
    , doc = libxmljs.parseXmlString(contents)
    , nodes = doc.childNodes()

  nodes.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(node)</span> {</span>
    <span class="keyword">var</span> name = node.name()
    node._name = name
    <span class="comment">//console.error(0, name, node)</span>
    <span class="keyword">switch</span> (name) {
      <span class="keyword">case</span> <span class="string">'text'</span>:
        <span class="comment">// ignore; just '\n' whitespace</span>
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'depends_on'</span>:
        Import(node.attr(<span class="string">'path'</span>).value(), <span class="literal">true</span>)
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'class'</span>:
        node.name = node.attr(<span class="string">'name'</span>).value()
        exports.classes[node.name] = node
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'string_constant'</span>:
        _global[node.attr(<span class="string">'name'</span>).value()] = getValue(node)
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'enum'</span>:
        _global[node.attr(<span class="string">'name'</span>).value()] = Number(getValue(node))
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'struct'</span>:
        <span class="comment">// TODO: Remove the try/catch when all the Struct formats are supported</span>
        <span class="comment">//       Still need Array and Union support.</span>
        <span class="keyword">try</span> {
          _global[node.attr(<span class="string">'name'</span>).value()] = struct.getStruct(getType(node))
        } <span class="keyword">catch</span> (e) {
          <span class="comment">//console.error('FAILED:\n', a)</span>
          <span class="comment">//console.error(e.stack)</span>
        }
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'field'</span>:
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'cftype'</span>:
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'constant'</span>:
        node.name = node.attr(<span class="string">'name'</span>).value()
        defineConstant(node, fw)
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'function'</span>:
        node.name = node.attr(<span class="string">'name'</span>).value()
        defineFunction(node, fw)
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'opaque'</span>:
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'informal_protocol'</span>:
        node.name = node.attr(<span class="string">'name'</span>).value()
        exports.informal_protocols[node.name] = node
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'function_alias'</span>:
        <span class="keyword">break</span>;
      <span class="keyword">default</span>:
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'unkown tag: '</span>+ node.name)
        <span class="keyword">break</span>;
    }
  })

}</code></pre></div><div class="part"><h3>defineConstant()</h3><div class="desc"><p>Sets up a <constant> tag onto the global exports.
These start out as simple JS getters, so that the underlying
symbol pointer can be lazy-loaded on-demand.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code><span class="function"><span class="keyword">function</span> <span class="title">defineConstant</span> <span class="params">(node, fw)</span> {</span>
  <span class="keyword">var</span> name = node.name
    , type = getType(node)
  _global.__defineGetter__(name, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> ptr = fw.lib.get(name) <span class="comment">// TODO: Cache the pointer after the 1st call</span>
    ptr._type = <span class="string">'^'</span> + type
    <span class="keyword">var</span> val = ptr.deref()
    <span class="keyword">return</span> val
  })
}</code></pre></div><div class="part"><h3>defineFunction()</h3><div class="desc"><p>Sets up a <function> tag onto the global exports.
These start out as simple JS getters, so that the underlying
function pointer can be lazy-loaded on-demand.</p>
</div><button class="show-code">Show Code</button><pre class="code"><code><span class="function"><span class="keyword">function</span> <span class="title">defineFunction</span> <span class="params">(node, fw)</span> {</span>
  <span class="keyword">var</span> name = node.name
  _global.__defineGetter__(name, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//console.error(require('util').inspect(a, true, 10))</span>
    <span class="comment">// TODO: Handle 'variadic' arg functions (NSLog), will require</span>
    <span class="comment">//       a "function generator" to get a Function from the passed</span>
    <span class="comment">//       in args (and guess at the types that were passed in...)</span>
    debug(<span class="string">'loading function pointer for:'</span>, name)
    <span class="keyword">var</span> isInline = node.attr(<span class="string">'inline'</span>)
    <span class="keyword">if</span> (isInline &amp;&amp; isInline.value() === <span class="string">'true'</span>) {
      debug(<span class="string">'function "%s" is declared as an inline function pointer:'</span>, name)
      assert.ok(fw.inline, name+<span class="string">', '</span>+fw.name+<span class="string">': declared inline but could not find inline dylib!'</span>)
    }
    node.args = []
    node.childNodes().forEach(<span class="function"><span class="keyword">function</span> <span class="params">(n, i)</span> {</span>
      <span class="keyword">var</span> type = n.name()
      <span class="comment">//console.error(i, type, n.toString())</span>
      <span class="keyword">switch</span> (type) {
        <span class="keyword">case</span> <span class="string">'arg'</span>:
          node.args.push(flattenNode(n))
          <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'retval'</span>:
          node.retval = flattenNode(n)
          <span class="keyword">break</span>;
        <span class="keyword">default</span>:
          <span class="keyword">break</span>;
      }
    })
    <span class="comment">//console.error(node)</span>
    <span class="keyword">var</span> ptr = (isInline ? fw.inline : fw.lib).get(name)
      , unwrapper = IMP.createUnwrapperFunction(ptr, node)
    unwrapper.info = node
    <span class="keyword">delete</span> _global[name]
    <span class="keyword">return</span> _global[name] = unwrapper
  })
}

<span class="function"><span class="keyword">function</span> <span class="title">flattenNode</span> <span class="params">(node)</span> {</span>
  node.type = getType(node)
  <span class="keyword">var</span> functionPointer = node.attr(<span class="string">'function_pointer'</span>)
  <span class="keyword">if</span> (functionPointer &amp;&amp; functionPointer.value() === <span class="string">'true'</span>) {
    node.function_pointer = <span class="string">'true'</span> <span class="comment">// XXX: Remove? Used by the function_pointer test case</span>
    node.args = []
    node.childNodes().forEach(<span class="function"><span class="keyword">function</span> <span class="params">(n, i)</span> {</span>
      <span class="keyword">var</span> type = n.name()
      <span class="keyword">switch</span> (type) {
        <span class="keyword">case</span> <span class="string">'arg'</span>:
          node.args.push(flattenNode(n))
          <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'retval'</span>:
          node.retval = flattenNode(n)
          <span class="keyword">break</span>;
        <span class="keyword">default</span>:
          <span class="keyword">break</span>;
      }
    })
  }
  <span class="keyword">return</span> node
}</code></pre></div></div><div id="footer">NodObjC &copy; 2011-2012 Nathan Rajlich. Documentation generated by <a href="https://github.com/visionmedia/dox">dox</a>.</div><a href="http://github.com/TooTallNate/NodObjC"><img id="ribbon" src="https://a248.e.akamai.net/camo.github.com/e6bef7a091f5f3138b8cd40bc3e114258dd68ddf/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub"></a></body></html>
